<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
  <title>Google Analytics (<%= settings.frequency.capitalize %>)</title>

  <style type="text/css">
    body {
      background: #fff;
      color: #000;
      width: 384px;
      padding: 0;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    .chart {
      width: 360px;
      height: 180px;
    }
    .line {
      fill: none;
      stroke-width: 3px;
    }
    .line-most-recent {
      stroke: #000;
    }
    .line-least-recent {
      stroke: #999;
    }

    /* The x and y axes themselves. */
    .axis-y path {
      stroke: #000;
      shape-rendering: crispEdges;
    }
    /* Horizontal lines behind the graph. */
    .axis-y .tick line {
      stroke: #000;
      shape-rendering: crispEdges;
    }
    /* The individual ticks. */
    .axis-x .tick line {
      stroke: #000;
      shape-rendering: crispEdges;
    }

  </style>

  <%# Include the d3 JS so that it renders inline. The BERG Cloud renderer seems to have problems when JS files are included as scripts. %>
  <%= erb(:js_d3, :layout => false) %>

  <script>
    window.onload = function() {

      function draw_chart(chart_number, chart_data) {
        // Size of whole chart, including axes and space around it:
        var outer_width = 384;
        var outer_height = 180;
        var margin = {top: 0, right: 10, bottom: 30, left: 20};
        // Size of the area of the chart with the actual lines on:
        var inner_width = outer_width - margin.left - margin.right;
        var inner_height = outer_height - margin.top - margin.bottom;

        // Turn a date/time string into a Date object.
        var parseDate = d3.time.format('%H%M').parse;

        // How we want the X-Axis dates/times formatted.
        var x_tick_format = d3.time.format('%H');

        // The scales.
        var x = d3.time.scale().range([0, inner_width]);

        var y = d3.scale.linear().range([inner_height, 0]);

        // I don't understand this one...
        var scale = d3.scale.ordinal();

        // The axes.
        var xAxis = d3.svg.axis().scale(x).orient('bottom')
                      .tickSize(6, 0, 0)
                      .tickFormat(function(d) { return x_tick_format(d); });

        var yAxis = d3.svg.axis().scale(y).orient('left')
                      .tickSize(-inner_width, 0, 0)
                      .ticks(5);

        var line = d3.svg.line()
                    .interpolate('basis')
                    .x(function(d) { return x(d.date); })
                    .y(function(d) { return y(d.visits ); });

        // The main chart area.
        var svg = d3.select('#chart-'+chart_number).append('svg')
            .attr('width', outer_width)
            .attr('height', outer_height)
          .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        // Now draw the chart's axes and lines.
        d3plot(chart_data);

        function d3plot(chart_data) {
          // I don't know...
          // Something like extracting the names of the periods.
          scale.domain(d3.keys(chart_data[0]).filter(
                                  function(key) { return key !== 'date'; }));

          // Turn the date strings into Date objects.
          chart_data.forEach(function(d) {
            d.date = parseDate(d.date);
          });

          // Change from the chart_data format:
          // [{date:Date, 'least-recent':7, 'most-recent':12}, {}...]
          // to a different format for periods:
          // [
          //  {name:'least-recent', values:[{date:Date, visits:7}, {}...]},
          //  {name:'most-recent', values:[{date:Date, visits:7}, {}...]}
          // ]
          var periods = scale.domain().map(function(name) {
            return {
              name: name,
              values: chart_data.map(function(d) {
                return {date: d.date, visits: +d[name]};
              })
            };
          });

          // Set the min and max of the x axis.
          x.domain(d3.extent(chart_data, function(d) { return d.date; }));

          // Set the min and max of the y axis.
          y.domain([
            0,
            d3.max(periods, function(c) {
              return d3.max(c.values, function(v) {return v.visits; }); })
          ]);

          // Draw the two axes we prepared earlier.
          svg.append('g')
              .attr('class', 'axis axis-x')
              .attr('transform', 'translate(0,' + inner_height + ')')
              .call(xAxis);

          svg.append('g')
              .attr('class', 'axis axis-y')
              .call(yAxis);

          // Erm... preparing to draw the lines?
          var period = svg.selectAll('.period')
              .data(periods)
            .enter().append('g')
              .attr('class', 'period');
            
          // Draw each of the lines.
          period.append('path')
              .attr('class', function(d) { return 'line line-'+d.name; })
              .attr('d', function(d) { return line(d.values); });
        };
      };

      <% @profiles_data.each_with_index do |p, profile_idx| %>
        var data = [];

        <% p[:periods][1][:visits].each_with_index do |v, visit_idx| %>
          data.push({
            // These need to be this way around, so that the least recent
            // line is drawn first, and then the most recent on top.
            'least-recent': <%= v.visits %>,
            'most-recent': <%= p[:periods][0][:visits].to_a[visit_idx].visits %>,
            'date': '<%= v.hour %>00'
          });
        <% end %>

        draw_chart(<%= profile_idx %>, data);

      <% end %>
    };

  </script>

</head>
<body>
  <h1>Google Analytics (<%= settings.frequency.capitalize %>)</h1>

  <% @profiles_data.each_with_index do |p, idx| %>
    <h2><%= p[:name] %></h2>

    <% if p[:periods][0][:start_date] == p[:periods][0][:end_date] %>
      <p>For <%= p[:periods][0][:start_date] %>.</p>
    <% else %>
      <p>From <%= p[:periods][0][:start_date] %> to <%= p[:periods][0][:end_date] %>.</p>
    <% end %>

    <h3>Visits</h3>

    <div id="chart-<%= idx %>" class="chart"></div>

<% 
=begin %>
    <h4><% if settings.frequency == 'weekly' %>Last week<% else %>Yesterday<% end %></h4>
    <ul>
      <% p[:periods][0][:visits].each do |v| %>
        <li><%= v.date %><% if settings.frequency == 'daily' %> <%= v.hour %>:00<% end %> – <%= v.visits %></li>
      <% end %> 
    </ul>

    <h4>Previous</h4>
    <ul>
      <% p[:periods][1][:visits].each do |v| %>
        <li><%= v.date %><% if settings.frequency == 'daily' %> <%= v.hour %>:00<% end %> – <%= v.visits %></li>
      <% end %> 
    </ul>
<% 
=end %>

    <h3>Totals</h2>
    <p>Visits: 
      <% if p[:periods][0][:total_visits] > p[:periods][1][:total_visits] %>
      ^
      <% elsif p[:periods][0][:total_visits] < p[:periods][1][:total_visits] %>
      v
      <% else %>
      –
      <% end %>
      <%= p[:periods][0][:total_visits] %> (<%= p[:periods][1][:total_visits] %>)</p>
    <p>Visitors: 
      <% if p[:periods][0][:total_visitors] > p[:periods][1][:total_visitors] %>
      ^
      <% elsif p[:periods][0][:total_visitors] < p[:periods][1][:total_visitors] %>
      v
      <% else %>
      –
      <% end %>
      <%= p[:periods][0][:total_visitors] %> (<%= p[:periods][1][:total_visitors] %>)</p>
    <p>Pageviews:
      <% if p[:periods][0][:total_pageviews] > p[:periods][1][:total_pageviews] %>
      ^
      <% elsif p[:periods][0][:total_pageviews] < p[:periods][1][:total_pageviews] %>
      v
      <% else %>
      –
      <% end %>
      <%= p[:periods][0][:total_pageviews] %> (<%= p[:periods][1][:total_pageviews] %>)</p>
  <% end %>



</body>
</html>
