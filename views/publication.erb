<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
  <title>Google Analytics (<%= settings.frequency.capitalize %>)</title>

  <style type="text/css">
    body {
      background: #fff;
      color: #000;
      width: 384px;
      padding: 0;
      margin: 0;
      font-family: Arial, sans-serif;
      font-size: 16px;
    }
    h1 {
      border-top: 5px solid #000;
      margin: 0;
      padding: 10px 10px;
      font-size: 24px;
    }
    h2 {
      background: #000;
      color: #fff;
      padding: 5px 10px;
      margin: 0 0 10px 0;
      font-size: 20px;
      white-space: nowrap;
      overflow: hidden;
    }
    h3 {
      font-size: 18px;
      margin: 10px;
      padding: 0;
    }
    p, table {
      margin: 0 0 10px 0;
      padding: 0 10px;
    }
    .profile {
      margin-bottom: 20px;
    }
    .profile:last-child {
      border-bottom: 5px solid #000;
      padding-bottom: 20px;
    }
    .totals {
      margin-top: 20px;
    }
    table {
      margin: 0 auto;
    }
    td {
      padding-right: 10px;
    }
    td.label {
      font-weight: bold;
      text-align: right;
    }
    td.indicator {
      font-size: 18px;
    }
    td.num {
      text-align: right;
    }


    .chart {
      /* Dimensions of overall chart, including axes and internal margins. */
      width: 374px;
      height: 180px;
      margin: 0 0 0 10px;
    }
    .line {
      fill: none;
      stroke: #000;
    }
    .line_most_recent {
      stroke-width: 4px;
    }
    .line_least_recent {
      stroke-width: 1px;
    }

    /* The x and y axes themselves. */
    .axis-y path {
      stroke: #000;
      shape-rendering: crispEdges;
    }
    /* Horizontal lines behind the graph. */
    .axis-y .tick line {
      stroke: #000;
      shape-rendering: crispEdges;
    }
    /* The individual ticks. */
    .axis-x .tick line {
      stroke: #000;
      shape-rendering: crispEdges;
    }
    .axis text {
      font-size: 14px;
    }

  </style>

  <%# Include the d3 JS so that it renders inline. The BERG Cloud renderer seems to have problems when JS files are included as scripts. %>
  <%= erb(:js_d3, :layout => false) %>

  <script>
    window.onload = function() {

      function draw_chart(chart_id, chart_data) {

        // A bit clunky - find the maximum value of y (visits) for this chart:
        var max_y = 0;
        chart_data.forEach(function(d) {
          if (d.least_recent > max_y) {
            max_y = d.least_recent;
          };
          if (d.most_recent > max_y) {
            max_y = d.most_recent;
          };
        });
        // Work out how much left margin (in pixels) we need
        // to leave for that many digits (and commas).
        var left_margin = max_y.toString().length * 9.2;

        // Size of whole chart, including axes and space around it:
        var outer_width = document.getElementById(chart_id).offsetWidth;
        var outer_height = document.getElementById(chart_id).offsetHeight;
        var margin = {top: 0, right: 10, bottom: 20, left: left_margin};
        // Size of the area of the chart with the actual lines on:
        var inner_width = outer_width - margin.left - margin.right;
        var inner_height = outer_height - margin.top - margin.bottom;

        // Turn a date/time string into a Date object.
        var parseDate = d3.time.format('%H%M').parse;

        // The scales.
        var x = d3.time.scale().range([0, inner_width]);

        var y = d3.scale.linear().range([inner_height, 0]);

        // I don't understand this one...
        var scale = d3.scale.ordinal();

        // How we want the X-Axis dates/times formatted.
        var x_tick_format = d3.time.format('%H:00');

        // Add commas in thousands.
        var y_tick_format = d3.format(',');

        // Explicitly set the x axis to show ticks every four hours.
        var x_tick_values = [parseDate(chart_data[0]['date']),
                              parseDate(chart_data[4]['date']),
                              parseDate(chart_data[8]['date']),
                              parseDate(chart_data[12]['date']),
                              parseDate(chart_data[16]['date']),
                              parseDate(chart_data[20]['date'])];
        // The axes.
        var xAxis = d3.svg.axis().scale(x).orient('bottom')
                      .tickSize(6, 0, 0)
                      .tickValues(x_tick_values)
                      .tickFormat(function(d) { return x_tick_format(d); });

        var yAxis = d3.svg.axis().scale(y).orient('left')
                      .tickSize(-inner_width, 0, 0)
                      .ticks(5)
                      .tickFormat(function(d) { return y_tick_format(d); });

        var line = d3.svg.line()
                    .interpolate('basis')
                    .x(function(d) { return x(d.date); })
                    .y(function(d) { return y(d.visits ); });

        // The main chart area.
        var svg = d3.select('#'+chart_id).append('svg')
            .attr('width', outer_width)
            .attr('height', outer_height)
          .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        // Now draw the chart's axes and lines.
        d3plot(chart_data);

        function d3plot(chart_data) {
          // I don't know...
          // Something like extracting the names of the periods.
          scale.domain(d3.keys(chart_data[0]).filter(
                                  function(key) { return key !== 'date'; }));

          // Turn the date strings into Date objects.
          chart_data.forEach(function(d) {
            d.date = parseDate(d.date);
          });

          // Change from the chart_data format:
          // [{date:Date, 'least_recent':7, 'most_recent':12}, {}...]
          // to a different format for periods:
          // [
          //  {name:'least_recent', values:[{date:Date, visits:7}, {}...]},
          //  {name:'most_recent', values:[{date:Date, visits:7}, {}...]}
          // ]
          var periods = scale.domain().map(function(name) {
            return {
              name: name,
              values: chart_data.map(function(d) {
                return {date: d.date, visits: +d[name]};
              })
            };
          });

          // Set the min and max of the x axis.
          x.domain(d3.extent(chart_data, function(d) { return d.date; }));

          // Set the min and max of the y axis.
          y.domain([
            0,
            d3.max(periods, function(c) {
              return d3.max(c.values, function(v) {return v.visits; }); })
          ]);

          // Draw the two axes we prepared earlier.
          svg.append('g')
              .attr('class', 'axis axis-x')
              .attr('transform', 'translate(0,' + inner_height + ')')
              .call(xAxis);

          svg.append('g')
              .attr('class', 'axis axis-y')
              .call(yAxis);

          // Erm... preparing to draw the lines?
          var period = svg.selectAll('.period')
              .data(periods)
            .enter().append('g')
              .attr('class', 'period');
            
          // Draw each of the lines.
          period.append('path')
              .attr('class', function(d) { return 'line line_'+d.name; })
              .attr('d', function(d) { return line(d.values); });
        };
      };

      <%# Put all the data into a JS structure for each profile, and make the chart. %>
      <% @profiles_data.each_with_index do |p, profile_idx| %>
        var data = [];

        <% p[:periods][1][:visits].each_with_index do |v, visit_idx| %>
          data.push({
            // These need to be this way around, so that the least recent
            // line is drawn first, and then the most recent on top.
            // I think.
            'least_recent': <%= v.visits %>,
            'most_recent': <%= p[:periods][0][:visits].to_a[visit_idx].visits %>,
            'date': '<%= v.hour %>00'
          });
        <% end %>

        draw_chart('chart-'+<%= profile_idx %>, data);
      <% end %>
    };

  </script>

</head>
<body>

  <h1>Google Analytics (<%= settings.frequency.capitalize %>)</h1>

  <% @profiles_data.each_with_index do |p, idx| %>
    <div class="profile">
      <h2><%= p[:name] %></h2>

      <p class="date">
        <% if settings.frequency == 'weekly' %>
          From <%= @periods[0][:start] %> to <%= @peoriods[0][:end] %>
        <% else %>
          <%= @periods[0][:start].strftime('%a %e %b %Y') %> compared to previous&nbsp;<%= @periods[1][:start].strftime('%A') %>
        <% end %>
      </p>

      <h3>Visits <% if settings.frequency == 'weekly' %>each day<% else %>per hour<% end %></h3>

      <div id="chart-<%= idx %>" class="chart"></div>

      <table class="totals">
        <tr>
          <td class="label">Visits</td> 
          <td class="indicator">
            <% if p[:periods][0][:total_visits] > p[:periods][1][:total_visits] %>
            ▲
            <% elsif p[:periods][0][:total_visits] < p[:periods][1][:total_visits] %>
            ▼
            <% else %>
            –
            <% end %>
          </td>
          <td class="num">
            <strong><%= p[:periods][0][:total_visits].to_s.reverse.gsub(/...(?=.)/,'\&,').reverse %></strong>
          </td>
          <td class="num">
            (<%= p[:periods][1][:total_visits].to_s.reverse.gsub(/...(?=.)/,'\&,').reverse %>)
          </td>
        </tr>

        <tr>
          <td class="label">Visitors</td>
          <td class="indicator">
            <% if p[:periods][0][:total_visitors] > p[:periods][1][:total_visitors] %>
            ▲ 
            <% elsif p[:periods][0][:total_visitors] < p[:periods][1][:total_visitors] %>
            ▼
            <% else %>
            –
            <% end %>
          </td>
          <td class="num">
            <strong><%= p[:periods][0][:total_visitors].to_s.reverse.gsub(/...(?=.)/,'\&,').reverse %></strong>
          </td>
          <td class="num">
            (<%= p[:periods][1][:total_visitors].to_s.reverse.gsub(/...(?=.)/,'\&,').reverse %>)
          </td>
        </tr>

        <tr>
          <td class="label">Pageviews</td>
          <td class="indicator">
            <% if p[:periods][0][:total_pageviews] > p[:periods][1][:total_pageviews] %>
            ▲
            <% elsif p[:periods][0][:total_pageviews] < p[:periods][1][:total_pageviews] %>
            ▼
            <% else %>
            –
            <% end %>
          </td>
          <td class="num"> 
            <strong><%= p[:periods][0][:total_pageviews].to_s.reverse.gsub(/...(?=.)/,'\&,').reverse %></strong>
          </td>
          <td class="num">
            (<%= p[:periods][1][:total_pageviews].to_s.reverse.gsub(/...(?=.)/,'\&,').reverse %>)
          </td>
        </tr>

      </table> <!-- .totals -->
    </div> <!-- .profile -->
  <% end %>

</body>
</html>
